/* ==================================================
 * SimpleNLG: An API for Natural Language Generation
 * ==================================================
 *
 * Copyright (c) 2007, the University of Aberdeen
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted FOR RESEARCH PURPOSES ONLY, provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, 
 * 		this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation and/or 
 *    other materials provided with the distribution.
 * 3. Neither the name of the University of Aberdeen nor the names of its contributors 
 * 	  may be used to endorse or promote products derived from this software without 
 *    specific prior written permission.
 *    
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 *    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 *    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 *    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE 
 *    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 *    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
 *     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *     
 *  Redistribution and use for purposes other than research requires special permission by the
 *  copyright holders and contributors. Please contact Ehud Reiter (ereiter@csd.abdn.ac.uk) for
 *  more information.
 *     
 *	   =================    
 *     Acknowledgements:
 *     =================
 *     This library contains a re-implementation of some rules derived from the MorphG package
 *     by Guido Minnen, John Carroll and Darren Pearce. You can find more information about MorphG
 *     in the following reference:
 *     	Minnen, G., Carroll, J., and Pearce, D. (2001). Applied Morphological Processing of English.
 *     		Natural Language Engineering 7(3): 207--223.
 *     Thanks to John Carroll (University of Sussex) for permission to re-use the MorphG rules. 
 */
package simplenlg.test;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.junit.Before;
import org.junit.Test;

import simplenlg.features.Case;
import simplenlg.features.Gender;
import simplenlg.features.NumberAgr;
import simplenlg.features.Person;
import simplenlg.lexicon.Lexicon;
import simplenlg.lexicon.lexicalitems.Constants;
import simplenlg.lexicon.lexicalitems.Pronoun;

// TODO: Auto-generated Javadoc
/**
 * Various tests for inflection in the lexicon. This consists of two methods,
 * one for nouns and one for verbs. In each method, there is a data file loaded,
 * consisting of several baseforms with the inflectional forms generated using
 * J. Carroll et al's MorphG. The test then uses the lexicon to compare the same
 * inflectional forms generated by the lexicon to the MorphG output.
 * 
 * <P>
 * NOTE: Edit the code for the correct location of the noun and verb files.
 * 
 * @author agatt
 */
public class InflectionTest extends TestCase {

	/** file containing noun morphG inflectional forms */
	public static String nounFile = "testData\\nounForms.csv";

	/** file containing verb morphG inflectional forms */
	public static String verbFile = "testData\\verbForms.csv";

	/** The lex. */
	private Lexicon lex;

	// morphG plural forms for nouns
	Map<String, String> plurals;

	// morphG inflected forms for verbs
	Map<String, List<String>> verbs;

	/**
	 * Load the words.
	 */
	@Override
	@Before
	public void setUp() {
		this.lex = new Lexicon();
		this.plurals = new HashMap<String, String>();
		this.verbs = new HashMap<String, List<String>>();
		String workingDir = System.getProperty("user.dir");
		loadNouns(new File(workingDir, InflectionTest.nounFile));
		loadVerbs(new File(workingDir, InflectionTest.verbFile));
	}

	/**
	 * Load nouns.
	 * 
	 * @param file
	 *            the file
	 */
	private void loadNouns(File file) {

		try {
			BufferedReader reader = new BufferedReader(new FileReader(file));
			StringTokenizer tok;

			while (reader.ready()) {
				String nextLine = reader.readLine();

				// ignore comments in the file
				if (nextLine.startsWith("//")) {
					continue;
				}

				tok = new StringTokenizer(nextLine, ",");
				int i = -1;
				String head = null;

				while (tok.hasMoreTokens()) {
					String word = tok.nextToken().trim();
					i++;

					if (i == 0) {
						head = word;
					} else {
						this.plurals.put(head, word);
					}
				}

			}

		} catch (IOException ioe) {
			System.err.println(ioe.getMessage());
			System.exit(-1);
		}
	}

	/**
	 * Load verbs.
	 * 
	 * @param file
	 *            the file
	 */
	private void loadVerbs(File file) {

		try {
			BufferedReader reader = new BufferedReader(new FileReader(file));
			StringTokenizer tok;

			while (reader.ready()) {
				String nextLine = reader.readLine().trim();

				// ignore comments in the file
				if (nextLine.startsWith("//")) {
					continue;
				}

				tok = new StringTokenizer(nextLine, ",");
				int i = -1;
				String head = null;

				while (tok.hasMoreTokens()) {
					String word = tok.nextToken().trim();
					i++;

					if (i == 0) {
						this.verbs.put(word, new ArrayList<String>());
						head = word;

					} else {
						this.verbs.get(head).add(word);
					}
				}
			}

		} catch (IOException ioe) {
			System.err.println(ioe.getMessage());
			System.exit(-1);
		}
	}

	/**
	 * Test plurals, comparing generated forms to the forms in file.
	 */
	@Test
	public void testNouns() {

		for (String noun : this.plurals.keySet()) {
			String filePlural = this.plurals.get(noun).toLowerCase();
			String lexPlural = this.lex.getPlural(noun).toLowerCase();
			Assert.assertEquals(filePlural, lexPlural);
		}
	}

	/**
	 * Test verb inflections, comparing generated forms to forms in file.
	 */
	@Test
	public void testVerbs() {

		for (String verb : this.verbs.keySet()) {
			List<String> fileForms = this.verbs.get(verb);
			List<String> lexForms = Arrays.asList(new String[] {
					this.lex.getPast(verb), this.lex.getPastParticiple(verb),
					this.lex.getPresentParticiple(verb),
					this.lex.getPresent3SG(verb) });
			Assert.assertEquals(fileForms, lexForms);
		}
	}

	/**
	 * Test that default lexicon deals with pronouns properly
	 */
	public void testPronouns() {
		Pronoun we = Constants.getPronoun(Person.FIRST, NumberAgr.PLURAL,
				Gender.NEUTER, Case.NOMINATIVE, false);
		Assert.assertEquals(we.getBaseForm(), "we");

		Pronoun our = Constants.getPronoun(Person.FIRST, NumberAgr.PLURAL,
				Gender.NEUTER, Case.NOMINATIVE, true);
		Assert.assertEquals(our.getBaseForm(), "our");

		Pronoun ours = Constants.getPronoun(Person.FIRST, NumberAgr.PLURAL,
				Gender.NEUTER, Case.NOM_ACC, true);
		Assert.assertEquals(ours.getBaseForm(), "ours");
	}

}
